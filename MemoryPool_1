#include <iostream>
#include <vector>
#include <memory>
#include <cstdlib>

static inline std::size_t align_up(std::size_t n, std::size_t align) {
    return (n + align - 1) & ~(align - 1);
}

class FixedSizePool {
public:
    explicit FixedSizePool(std::size_t block_size,
                            std::size_t blocks_per_page = 1024){
        blocks_per_page_ = blocks_per_page;
        block_size_ = adjusted_block_size(block_size);
        free_list_ = nullptr;
    }
    ~FixedSizePool() {
        for (void* p : pages_) {
            ::operator delete[](p);
        }
    }

    void* allocate(){
        if(!free_list_){
            expand();
        }
        Node* head = free_list_;
        free_list_ = head->next;
        return head;
    }

    void deallocate(void* p) {
        if(!p) return;
        Node* node = static_cast<Node*>(p);
        node->next = free_list_;
        free_list_ = node;
    }

    std::size_t block_size() const {
        return block_size_;
    }

    std::size_t blocks_per_page() const {
        return blocks_per_page_;
    }




private:
    std::size_t adjusted_block_size(std::size_t s)  {
        std::size_t min = sizeof(void*);
        std::size_t a = align_up (s < min ? min : s, alignof(void*));
        return a;
    }

    void expand(){
        std::size_t page_bytes = block_size_ * blocks_per_page_;
        char* page = static_cast<char*>(::operator new[](page_bytes));
        pages_.push_back(page);

        for(std::size_t i = 0; i < blocks_per_page_; i++){
            char* addr = page + i * block_size_;
            Node *n = reinterpret_cast<Node*>(addr);
            n->next = free_list_;
            free_list_ = n;
        }
    }

    struct Node{
        Node* next;
    };

    std::size_t block_size_; // Size of each block
    std::size_t blocks_per_page_;  // Number of blocks per page
    Node* free_list_; // Pointer to the head of the free list
    std::vector<void*> pages_;

};

struct Particle{
    float x,y,z;
    int life;

    static void* operator new(std::size_t n);
    static void operator delete(void * p) noexcept;

    void update(){++life;}
};

static FixedSizePool g_particle_pool(sizeof(Particle), 4096);

void* Particle::operator new(std::size_t n){
    return g_particle_pool.allocate();
}

void Particle::operator delete(void *p) noexcept{
    g_particle_pool.deallocate(p);
}

int main(){
    std::vector<Particle> vec;

}
